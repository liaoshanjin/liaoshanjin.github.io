<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.59.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="苦味糖" />
  <meta property="og:url" content="https://liaoshanjin.github.io/laravel/larave-response-exception/" />
  <link rel="canonical" href="https://liaoshanjin.github.io/laravel/larave-response-exception/" /><link rel="alternate" type="application/atom+xml" href="https://liaoshanjin.github.ioindex.xml" title="苦味糖的博客">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/liaoshanjin.github.io"
      },
      "articleSection" : "laravel",
      "name" : "自定义接口 response 和 异常",
      "headline" : "自定义接口 response 和 异常",
      "description" : "封装返回的统一消息 接口主流返回 json 格式，其中包含 http状态码，status请求状态，data请求资源结果等等。需要我们有一个 API 接口全局都能有统一的格式和对应的数据处理。\n在 app\/Api\/Helpers 目录 (不存在目录自己新建) 下新建 ApiResponse.php 填入如下内容\n\x26lt;?php namespace App\\Api\\Helpers; use Symfony\\Component\\HttpFoundation\\Response as HttpBaseResponse; \/** * Trait ApiResponse * * @package App\\Api\\Helpers *\/ trait ApiResponse { \/** * @var int *\/ protected $httpCode = HttpBaseResponse::HTTP_OK; \/** * 设置 Http 的状态码 * * @param $code * * @return $this *\/ public function setHttpCode($code) { $this-\x26gt;httpCode = $code; return $this; } \/** * 获取 Http 状态码 * * @return int *\/ public function getHttpCode() { return $this-\x26gt;httpCode; } \/** * 最基础的一个返回 json * * @param $data * @param array $header * * @return \\Illuminate\\Http\\JsonResponse *\/ public function baseResponse($data, $header = []) { return \\Response::json($data, $this-\x26gt;getHttpCode(), $header); } \/** * 定义返回的格式 * * @param array $data * @param $messageStatus * @param null $httpCode * * @return \\Illuminate\\Http\\JsonResponse *\/ public function status(array $data, $messageStatus, $httpCode = null) { if ( !",
      "inLanguage" : "en-US",
      "author" : "苦味糖",
      "creator" : "苦味糖",
      "publisher": "苦味糖",
      "accountablePerson" : "苦味糖",
      "copyrightHolder" : "苦味糖",
      "copyrightYear" : "2019",
      "datePublished": "2019-10-24 17:09:10 \x2b0800 CST",
      "dateModified" : "2019-10-24 17:09:10 \x2b0800 CST",
      "url" : "https:\/\/liaoshanjin.github.io\/laravel\/larave-response-exception\/",
      "keywords" : [  ]
  }
</script>
<title>自定义接口 response 和 异常 - 苦味糖的博客</title>
  <meta property="og:title" content="自定义接口 response 和 异常 - 苦味糖的博客" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="封装返回的统一消息 接口主流返回 json 格式，其中包含 http状态码，status请求状态，data请求资源结果等等。需要我们有一个 API 接口全局都能有统一的格式和对应的数据处理。
在 app/Api/Helpers 目录 (不存在目录自己新建) 下新建 ApiResponse.php 填入如下内容
&lt;?php namespace App\Api\Helpers; use Symfony\Component\HttpFoundation\Response as HttpBaseResponse; /** * Trait ApiResponse * * @package App\Api\Helpers */ trait ApiResponse { /** * @var int */ protected $httpCode = HttpBaseResponse::HTTP_OK; /** * 设置 Http 的状态码 * * @param $code * * @return $this */ public function setHttpCode($code) { $this-&gt;httpCode = $code; return $this; } /** * 获取 Http 状态码 * * @return int */ public function getHttpCode() { return $this-&gt;httpCode; } /** * 最基础的一个返回 json * * @param $data * @param array $header * * @return \Illuminate\Http\JsonResponse */ public function baseResponse($data, $header = []) { return \Response::json($data, $this-&gt;getHttpCode(), $header); } /** * 定义返回的格式 * * @param array $data * @param $messageStatus * @param null $httpCode * * @return \Illuminate\Http\JsonResponse */ public function status(array $data, $messageStatus, $httpCode = null) { if ( !" />
  <meta name="description" content="封装返回的统一消息 接口主流返回 json 格式，其中包含 http状态码，status请求状态，data请求资源结果等等。需要我们有一个 API 接口全局都能有统一的格式和对应的数据处理。
在 app/Api/Helpers 目录 (不存在目录自己新建) 下新建 ApiResponse.php 填入如下内容
&lt;?php namespace App\Api\Helpers; use Symfony\Component\HttpFoundation\Response as HttpBaseResponse; /** * Trait ApiResponse * * @package App\Api\Helpers */ trait ApiResponse { /** * @var int */ protected $httpCode = HttpBaseResponse::HTTP_OK; /** * 设置 Http 的状态码 * * @param $code * * @return $this */ public function setHttpCode($code) { $this-&gt;httpCode = $code; return $this; } /** * 获取 Http 状态码 * * @return int */ public function getHttpCode() { return $this-&gt;httpCode; } /** * 最基础的一个返回 json * * @param $data * @param array $header * * @return \Illuminate\Http\JsonResponse */ public function baseResponse($data, $header = []) { return \Response::json($data, $this-&gt;getHttpCode(), $header); } /** * 定义返回的格式 * * @param array $data * @param $messageStatus * @param null $httpCode * * @return \Illuminate\Http\JsonResponse */ public function status(array $data, $messageStatus, $httpCode = null) { if ( !" />
  <meta property="og:locale" content="zh_CN" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet" href="/css/github-markdown.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="苦味糖的博客">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel="stylesheet">
  
  

  
</head>

<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">苦味糖的博客</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">自定义接口 response 和 异常</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2019-10-24 17:09:10 CST">
                24 Oct 2019
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://liaoshanjin.github.io/">@苦味糖</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          

<h3 id="封装返回的统一消息">封装返回的统一消息</h3>

<p>接口主流返回 <code>json</code> 格式，其中包含 <code>http状态码</code>，<code>status请求状态</code>，<code>data请求资源结果</code>等等。需要我们有一个 API 接口全局都能有统一的格式和对应的数据处理。</p>

<p>在 <code>app/Api/Helpers</code> 目录 (不存在目录自己新建) 下新建 <code>ApiResponse.php</code> 填入如下内容</p>

<pre><code class="language-php">&lt;?php

namespace App\Api\Helpers;

use Symfony\Component\HttpFoundation\Response as HttpBaseResponse;

/**
 * Trait ApiResponse
 *
 * @package App\Api\Helpers
 */
trait  ApiResponse
{

    /**
     * @var int
     */
    protected $httpCode = HttpBaseResponse::HTTP_OK;


    /**
     * 设置 Http 的状态码
     *
     * @param $code
     *
     * @return $this
     */
    public function setHttpCode($code)
    {
        $this-&gt;httpCode = $code;

        return $this;
    }


    /**
     * 获取 Http 状态码
     *
     * @return int
     */
    public function getHttpCode()
    {
        return $this-&gt;httpCode;
    }


    /**
     * 最基础的一个返回 json
     *
     * @param       $data
     * @param array $header
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function baseResponse($data, $header = [])
    {
        return \Response::json($data, $this-&gt;getHttpCode(), $header);
    }


    /**
     * 定义返回的格式
     *
     * @param array $data
     * @param       $messageStatus
     * @param null  $httpCode
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function status(array $data, $messageStatus, $httpCode = null)
    {
        if ( ! is_null($httpCode)) {
            $this-&gt;setHttpCode($httpCode);
        }

        $format = [
            'status' =&gt; $messageStatus,
            'code'   =&gt; $this-&gt;httpCode,
        ];

        $responseArray = array_merge($format, $data);

        return $this-&gt;baseResponse($responseArray);
    }


    /**
     * 默认成功的消息返回
     *
     * @param        $message
     * @param string $messageStatus
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function message($message, $messageStatus = 'success')
    {
        return $this-&gt;status(['message' =&gt; $message], $messageStatus);
    }


    /**
     * 数据返回
     *
     * @param        $data
     * @param string $messageStatus
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function success($data, $messageStatus = 'success')
    {
        return $this-&gt;status(['data' =&gt; $data], $messageStatus);
    }


    /**
     * 默认错误的消息返回
     *
     * @param        $message
     * @param string $messageStatus
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function error($message, $messageStatus = 'error')
    {
        return $this-&gt;status(['message' =&gt; $message], $messageStatus);
    }


    /**
     * 错误的时候消息返回
     *
     * @param        $message
     * @param int    $httpCode
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function failed($message, $httpCode = HttpBaseResponse::HTTP_BAD_REQUEST)
    {
        return $this-&gt;setHttpCode($httpCode)-&gt;error($message);
    }


    /**
     * 服务器错误返回
     *
     * @param string $message
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function internalError($message = &quot;服务器内部错误&quot;)
    {
        return $this-&gt;failed($message, HttpBaseResponse::HTTP_INTERNAL_SERVER_ERROR);
    }


    /**
     * 创建成功的时候提示
     *
     * @param string $message
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function created($message = 'created')
    {
        return $this-&gt;setHttpCode(HttpBaseResponse::HTTP_CREATED)-&gt;message($message);
    }


    /**
     * 删除时的返回
     *
     * @param string $message
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function deleted($message = 'deleted')
    {
        return $this-&gt;setHttpCode(HttpBaseResponse::HTTP_NO_CONTENT)-&gt;message($message);
    }


    /**
     * 没有找到的错误
     *
     * @param string $message
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function notFound($message = 'Not Found')
    {
        return $this-&gt;setHttpCode(HttpBaseResponse::HTTP_NOT_FOUND)-&gt;error($message);
    }


}
</code></pre>

<h3 id="异常自定义处理">异常自定义处理</h3>

<p>在 <code>app/Api/Helpers</code> 目录下新建 <code>ExceptionReport.php</code> 文件，填入以下内容：</p>

<pre><code class="language-php">&lt;?php

namespace App\Api\Helpers;

use Exception;
use Illuminate\Auth\Access\AuthorizationException;
use Illuminate\Auth\AuthenticationException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Http\Request;
use Illuminate\Support\Arr;
use Illuminate\Validation\ValidationException;
use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpKernel\Exception\UnauthorizedHttpException;


/**
 * Class ExceptionReport
 *
 * @package App\Api\Helpers
 */
class ExceptionReport
{

    use ApiResponse;

    /**
     * @var
     */
    public $exception;

    /**
     * @var
     */
    public $request;

    /**
     * @var
     */
    protected $report;


    /**
     * @var array
     */
    public $doReport = [
        UnauthorizedHttpException::class     =&gt; ['未登录或者登录已失效', 401],
        MethodNotAllowedHttpException::class =&gt; ['访问方式不正确', 405],
        NotFoundHttpException::class         =&gt; ['访问的路由不存在', 404],
        ModelNotFoundException::class        =&gt; ['模型没有找到', 404],
        AuthorizationException::class        =&gt; ['没有此权限', 403],
        AuthenticationException::class       =&gt; ['未授权的访问', 401],
        ValidationException::class           =&gt; [],
    ];


    /**
     * ExceptionReport constructor.
     *
     * @param $exception
     * @param $request
     */
    public function __construct(Exception $exception, Request $request)
    {
        $this-&gt;exception = $exception;
        $this-&gt;request   = $request;
    }


    /**
     * 接管错误异常
     *
     * @param \Exception $exception
     *
     * @return \App\Api\Helpers\ExceptionReport
     */
    public static function make(Exception $exception)
    {
        return new static($exception, \request());
    }


    /**
     * 判断异常是否已经自定义
     *
     * @return bool
     */
    public function canReport()
    {
        foreach (array_keys($this-&gt;doReport) as $exception) {
            if ($this-&gt;exception instanceof $exception) {
                $this-&gt;report = $exception;

                return true;
            }
        }

        return false;
    }

    /**
     * 反馈自定义的异常
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function report()
    {
        if ($this-&gt;exception instanceof ValidationException) {
            $error = Arr::first($this-&gt;exception-&gt;errors());

            return $this-&gt;failed(Arr::first($error), $this-&gt;exception-&gt;status);
        }

        $message = $this-&gt;doReport[$this-&gt;report];

        return $this-&gt;failed($message[0], $message[1]);
    }


    /**
     * 线上环境时的报错
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function prodReport()
    {
        return $this-&gt;failed('服务器内部错误', 500);
    }


}
</code></pre>

<h4 id="接管异常">接管异常</h4>

<p>修改 <code>app/Exceptions</code> 目录下的 <code>Handler.php</code> 文件</p>

<pre><code class="language-php">&lt;?php

namespace App\Exceptions;

use App\Api\Helpers\ExceptionReport;
use Exception;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;

/**
 * Class Handler
 *
 * @package App\Exceptions
 */
class Handler extends ExceptionHandler
{

    ....
    ....
    ....


    /**
     * 重构异常
     *
     * @param \Illuminate\Http\Request $request
     * @param \Exception               $exception
     *
     * @return \Illuminate\Http\JsonResponse|\Illuminate\Http\Response|\Symfony\Component\HttpFoundation\Response
     */
    public function render($request, Exception $exception)
    {
        if ($request-&gt;ajax() || $request-&gt;is('api/*')) {
            $e = ExceptionReport::make($exception);
            if ($e-&gt;canReport()) {
                return $e-&gt;report();
            }

            # 判断是否开启了 Debug ,开启则显示详细异常，否则使用自定义的异常
            if (env('APP_DEBUG')) {
                return parent::render($request, $exception);
            } else {
                return $e-&gt;prodReport();
            }

        }

        return parent::render($request, $exception);
    }

}
</code></pre>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
          </div>
        </div>
        <div class="row">
          <div class="col-xs-12">
            
          </div>
        </div>

        
        

        
        
        <div style="height: 50px;"></div>
        
        <div class="post-comments">
          <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://苦味糖.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

        </div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="/about/" target="_blank">关于我</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/liaoshanjin" target="_blank">Github</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  
  
    
    
  
</script>

  

</body>

</html>